# 3. Пользовательские типы в объектно-реляционных базах данных на примере PostgreSQL

[◀️ К списку вопросов](README.md)

## Содержание

- [Назначение и классификация пользовательских типов данных](#назначение-и-классификация-пользовательских-типов-данных)
- [Составные типы данных (composite)](#составные-типы-данных-composite)
- [Перечислимые типы данных (enum)](#перечислимые-типы-данных-enum)
- [Диапазонные типы данных (range)](#диапазонные-типы-данных-range)
- [Пример интеграции пользовательских типов с наследованием](#пример-интеграции-пользовательских-типов-с-наследованием)
- [Практические рекомендации](#практические-рекомендации)

## Назначение и классификация пользовательских типов данных

Пользовательские типы данных в PostgreSQL предназначены для:

- Моделирования сложных структур данных, соответствующих предметной области.
- Обеспечения строгой типизации для контроля целостности данных.
- Упрощения запросов за счёт использования логически связанных данных.
- Повышения читаемости и повторного использования кода в приложениях.

**Основные категории пользовательских типов:**

- **Составные типы (composite)**: Структуры, объединяющие несколько атрибутов различных типов, аналогичные структурам в языках программирования.
- **Перечислимые типы (enum)**: Фиксированные списки допустимых значений, обеспечивающие строгую валидацию.
- **Диапазонные типы (range)**: Интервалы значений (например, числовые или временные) с поддержкой операций над диапазонами.

> [Наверх ⬆️](#содержание)

## Составные типы данных (composite)

Составные типы позволяют группировать несколько атрибутов в единую структуру, которая может использоваться в таблицах, функциях или представлениях. Они подходят для представления объектов, таких как адреса, координаты или профили.

**Синтаксис создания:**

```sql
CREATE TYPE address AS (
    street TEXT,
    city TEXT,
    zip_code TEXT,
    country TEXT
);
```

**Использование в таблице:**

```sql
CREATE TABLE person (
    id SERIAL PRIMARY KEY,
    name TEXT NOT NULL,
    home_address address
);
```

**Вставка данных:**

```sql
INSERT INTO person (name, home_address)
VALUES ('Alice', ROW('123 Main St', 'New York', '10001', 'USA')::address);
```

**Доступ к полям составного типа:**

```sql
SELECT name, (home_address).city AS city FROM person;
```

**Изменение состава типа:**

- Добавление нового атрибута:

  ```sql
  ALTER TYPE address ADD ATTRIBUTE phone TEXT;
  ```

- Удаление атрибута (при отсутствии зависимостей):

  ```sql
  ALTER TYPE address DROP ATTRIBUTE zip_code;
  ```

- Переименование атрибута:

  ```sql
  ALTER TYPE address RENAME ATTRIBUTE city TO town;
  ```

**Удаление типа:**

```sql
DROP TYPE address CASCADE;
```

Опция `CASCADE` удаляет тип и все зависимости, такие как столбцы в таблицах, использующие этот тип. Без `CASCADE` удаление невозможно при наличии зависимостей.

**Особенности:**

- Составные типы автоматически создаются при определении таблиц (каждая таблица имеет соответствующий составной тип).
- Они поддерживают вложенные структуры, но не методы, в отличие от объектных СУБД.
- Использование составных типов упрощает работу с JSON-подобными данными, но требует явного указания структуры.

> [Наверх ⬆️](#содержание)

## Перечислимые типы данных (enum)

Перечислимые типы задают фиксированный набор допустимых значений, обеспечивая строгую валидацию и упрощая работу с категориальными данными. Они подходят для полей с ограниченным набором состояний, таких как статусы, роли или категории.

**Синтаксис создания:**

```sql
CREATE TYPE mood AS ENUM ('happy', 'sad', 'neutral', 'excited');
```

**Использование в таблице:**

```sql
CREATE TABLE diary_entry (
    id SERIAL PRIMARY KEY,
    entry_date DATE,
    mood mood
);
```

**Вставка данных:**

```sql
INSERT INTO diary_entry (entry_date, mood)
VALUES ('2025-06-01', 'happy');
```

**Изменение перечисления:**

- Добавление нового значения в конец списка:

  ```sql
  ALTER TYPE mood ADD VALUE 'angry';
  ```

- Добавление значения с указанием позиции:

  ```sql
  ALTER TYPE mood ADD VALUE 'calm' BEFORE 'neutral';
  ```

**Ограничения:**

- Удаление значений из перечислимого типа не поддерживается. Для этого требуется создать новый тип и обновить все зависимости.
- Порядок значений в `ENUM` важен, так как он влияет на сравнения (например, `'happy' < 'sad'`).

**Удаление типа:**

```sql
DROP TYPE mood CASCADE;
```

**Особенности:**

- Перечислимые типы эффективны для хранения категориальных данных, так как занимают мало места (4 байта на значение).
- Они обеспечивают строгую проверку значений на этапе вставки, предотвращая ошибки.

> [Наверх ⬆️](#содержание)

## Диапазонные типы данных (range)

Диапазонные типы представляют интервалы значений (числовые, временные и т.д.) и поддерживают операции, такие как пересечение, объединение или проверка вхождения. PostgreSQL имеет встроенные диапазоны (`int4range`, `daterange`, `tsrange`), но также позволяет создавать пользовательские.

**Синтаксис создания:**

```sql
CREATE TYPE int_range AS RANGE (
    subtype = integer,
    subtype_diff = int4mi
);
```

Параметр `subtype_diff` определяет функцию вычитания для базового типа, необходимую для операций с диапазонами.

**Использование в таблице:**

```sql
CREATE TABLE events (
    id SERIAL PRIMARY KEY,
    event_name TEXT,
    period int_range
);
```

**Вставка данных:**

```sql
INSERT INTO events (event_name, period)
VALUES ('Conference', '[10,20)');
```

Здесь `[10,20)` означает диапазон от 10 (включительно) до 20 (исключительно).

**Операции с диапазонами:**

```sql
-- Проверка пересечения
SELECT period && '[15,25)' FROM events;

-- Проверка вхождения значения
SELECT 15 <@ period FROM events;

-- Объединение диапазонов
SELECT period + '[20,30)' FROM events;
```

**Изменение типа:**

Прямое изменение диапазонных типов не поддерживается. Для изменения структуры нужно:

1. Создать новый тип с требуемыми параметрами.
2. Обновить все таблицы, использующие старый тип, с помощью `ALTER TABLE ... ALTER COLUMN ... TYPE`.
3. Удалить старый тип.

**Удаление типа:**

```sql
DROP TYPE int_range CASCADE;
```

**Особенности:**

- Диапазонные типы поддерживают индексы (например, GiST), что ускоряет операции поиска.
- Они полезны для задач, связанных с временными интервалами (например, бронирование, планирование) или числовыми диапазонами (например, ценовые категории).
- Поддерживаются операции, такие как `&&` (пересечение), `+` (объединение), `<@` (вхождение), что делает их мощным инструментом для аналитики.

> [Наверх ⬆️](#содержание)

## Пример интеграции пользовательских типов с наследованием

```sql
-- Создание составного типа
CREATE TYPE contact_info AS (
    email TEXT,
    phone TEXT
);

-- Родительская таблица
CREATE TABLE entity (
    id SERIAL PRIMARY KEY,
    name TEXT,
    contact contact_info
);

-- Дочерняя таблица
CREATE TABLE customer (
    loyalty_level TEXT
) INHERITS (entity);

-- Вставка данных
INSERT INTO customer (name, contact, loyalty_level)
VALUES ('Bob', ROW('bob@example.com', '555-1234')::contact_info, 'Gold');

-- Запрос с доступом к полям составного типа
SELECT name, (contact).email AS email, loyalty_level FROM customer;
```

Этот пример демонстрирует использование составного типа `contact_info` в иерархии таблиц, что позволяет компактно хранить и обрабатывать связанные данные.

> [Наверх ⬆️](#содержание)

## Практические рекомендации

1. **Выбор подходящего типа**:
   - Используйте составные типы для структурированных данных (например, адресов, координат).
   - Применяйте перечислимые типы для категориальных данных с фиксированным набором значений.
   - Выбирайте диапазонные типы для интервальных данных, требующих операций сравнения или пересечения.

2. **Управление зависимостями**:
   - Перед удалением или изменением типа проверяйте зависимости с помощью `\dT+` в psql.
   - Используйте `CASCADE` с осторожностью, чтобы избежать потери данных.

3. **Производительность**:
   - Составные типы увеличивают сложность запросов, поэтому используйте их только при необходимости.
   - Для больших таблиц с диапазонными типами создавайте GiST-индексы для ускорения операций.

> [Наверх ⬆️](#содержание)
