# 4. Пользовательские операторы в объектно-реляционных базах данных на примере PostgreSQL

[◀️ К списку вопросов](README.md)

## Содержание

- [Назначение пользовательских операторов](#назначение-пользовательских-операторов)
- [Создание пользовательского оператора](#создание-пользовательского-оператора)
  - [Дополнительные параметры оператора](#дополнительные-параметры-оператора)
- [Изменение пользовательского оператора](#изменение-пользовательского-оператора)
- [Удаление пользовательского оператора](#удаление-пользовательского-оператора)
- [Пример интеграции с пользовательским типом](#пример-интеграции-с-пользовательским-типом)
- [Практические рекомендации](#практические-рекомендации)

## Назначение пользовательских операторов

Пользовательские операторы используются для:

- Реализации специфических операций, таких как сравнение, объединение или вычисление, для пользовательских типов данных.
- Перегрузки стандартных операторов для новых типов (например, определение `+` для сложения геометрических объектов).
- Упрощения запросов за счёт использования интуитивных символов вместо явных вызовов функций.
- Интеграции с индексами (GiST, GIN, B-tree) через операторные классы для оптимизации производительности.
- Поддержки сложной бизнес-логики, например, операций над геометрическими или временными данными.

> [Наверх ⬆️](#содержание)

## Создание пользовательского оператора

Пользовательский оператор создаётся с помощью команды `CREATE OPERATOR`, которая связывает оператор с функцией, реализующей его логику. Необходимо указать типы аргументов и, при необходимости, дополнительные параметры.

**Пример: Оператор `#` для проверки пересечения прямоугольников:**

```sql
-- Функция для проверки пересечения прямоугольников
CREATE OR REPLACE FUNCTION rect_overlap(a box, b box)
RETURNS boolean AS $$
BEGIN
    RETURN a && b; -- Использует встроенный оператор пересечения
END;
$$ LANGUAGE plpgsql;

-- Создание оператора
CREATE OPERATOR # (
    LEFTARG = box,
    RIGHTARG = box,
    PROCEDURE = rect_overlap,
    COMMUTATOR = #,
    NEGATOR = !#
);
```

В этом примере оператор `#` проверяет, пересекаются ли два прямоугольника типа `box`. Параметры `COMMUTATOR` и `NEGATOR` задают симметричность и логическое отрицание оператора.

**Использование в запросе:**

```sql
SELECT box '((0,0),(2,2))' # box '((1,1),(3,3))';
```

### Дополнительные параметры оператора

При создании оператора можно указать следующие параметры для расширения функциональности:

- `LEFTARG` и `RIGHTARG`: Типы левого и правого операндов.
- `PROCEDURE`: Функция, реализующая логику оператора.
- `COMMUTATOR`: Указывает симметричный оператор (например, если `a # b` эквивалентно `b # a`, то `COMMUTATOR = #`).
- `NEGATOR`: Определяет оператор логического отрицания (например, `!#` для отрицания пересечения).
- `RESTRICT`: Функция ограничения для оптимизации запросов (используется планировщиком).
- `JOIN`: Функция для оптимизации соединений (например, в `JOIN` операциях).
- `HASHES`: Указывает поддержку хеш-индексов.
- `MERGES`: Указывает поддержку операций слияния (merge join).

**Пример с расширенными параметрами:**

```sql
-- Функция для возведения в степень
CREATE OR REPLACE FUNCTION custom_pow(a integer, b integer)
RETURNS integer AS $$
BEGIN
    RETURN POW(a, b)::integer;
END;
$$ LANGUAGE plpgsql;

-- Оператор для возведения в степень
CREATE OPERATOR ^^ (
    LEFTARG = integer,
    RIGHTARG = integer,
    PROCEDURE = custom_pow,
    COMMUTATOR = ^^,
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);
```

Здесь оператор `^^` реализует возведение в степень для целых чисел и поддерживает оптимизацию запросов через `RESTRICT` и `JOIN`.

> [Наверх ⬆️](#содержание)

## Изменение пользовательского оператора

Прямое изменение оператора через `ALTER OPERATOR` в PostgreSQL ограничено (например, можно изменить владельца или схему). Для изменения логики оператора необходимо:

1. Удалить существующий оператор.
2. Создать новый оператор с обновлённой функцией или параметрами.

**Пример изменения:**

```sql
-- Удаление оператора
DROP OPERATOR # (box, box);

-- Новая функция с изменённой логикой
CREATE OR REPLACE FUNCTION rect_overlap_strict(a box, b box)
RETURNS boolean AS $$
BEGIN
    RETURN a && b AND a @> b; -- Проверка строгого пересечения
END;
$$ LANGUAGE plpgsql;

-- Пересоздание оператора
CREATE OPERATOR # (
    LEFTARG = box,
    RIGHTARG = box,
    PROCEDURE = rect_overlap_strict,
    COMMUTATOR = #,
    NEGATOR = !#
);
```

> [Наверх ⬆️](#содержание)

## Удаление пользовательского оператора

Удаление выполняется командой `DROP OPERATOR` с указанием имени оператора и типов его аргументов:

```sql
DROP OPERATOR ^^ (integer, integer) CASCADE;
```

Опция `CASCADE` удаляет зависимости, такие как операторные классы или индексы. Если оператор перегружен (определён для разных типов), необходимо точно указать сигнатуру.

> [Наверх ⬆️](#содержание)

## Пример интеграции с пользовательским типом

```sql
-- Создание пользовательского типа
CREATE TYPE complex AS (
    real_part DOUBLE PRECISION,
    imag_part DOUBLE PRECISION
);

-- Функция сложения комплексных чисел
CREATE OR REPLACE FUNCTION complex_add(a complex, b complex)
RETURNS complex AS $$
BEGIN
    RETURN ROW(a.real_part + b.real_part, a.imag_part + b.imag_part)::complex;
END;
$$ LANGUAGE plpgsql;

-- Оператор сложения
CREATE OPERATOR + (
    LEFTARG = complex,
    RIGHTARG = complex,
    PROCEDURE = complex_add,
    COMMUTATOR = +
);

-- Использование
SELECT ROW(1.0, 2.0)::complex + ROW(3.0, 4.0)::complex;
```

Этот пример демонстрирует создание оператора `+` для пользовательского типа `complex`, что позволяет выполнять сложение комплексных чисел в SQL-запросах.

> [Наверх ⬆️](#содержание)

## Практические рекомендации

1. **Чёткое определение логики**: Убедитесь, что функция, связанная с оператором, корректно обрабатывает все возможные входные данные, включая `NULL`.
2. **Использование COMMUTATOR и NEGATOR**: Задавайте эти параметры для симметричных операторов и их отрицаний, чтобы планировщик запросов мог оптимизировать выполнение.
3. **Интеграция с индексами**: Для часто используемых операторов создавайте операторные классы для поддержки GiST, GIN или B-tree индексов.
4. **Документирование**: Описывайте назначение оператора и его логику в документации, так как пользовательские операторы могут быть неочевидны для других разработчиков.
5. **Тестирование**: Проверяйте поведение оператора в различных сценариях, включая граничные случаи и работу с большими данными.
6. **Избежание перегрузки**: Не создавайте слишком много операторов с похожими функциями, чтобы не усложнять схему базы данных.

> [Наверх ⬆️](#содержание)
