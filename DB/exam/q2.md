# 2. Проектирование и создание объектно-реляционных баз данных с учетом объектных расширений на примере PostgreSQL

[◀️ К списку вопросов](README.md)

## Содержание

- [Основы объектно-реляционного подхода в PostgreSQL](#основы-объектно-реляционного-подхода-в-postgresql)
- [Наследование таблиц в PostgreSQL](#наследование-таблиц-в-postgresql)
- [Синтаксис реализации наследования](#синтаксис-реализации-наследования)
- [Что наследуется и что не наследуется](#что-наследуется-и-что-не-наследуется)
- [Особенности работы с наследованием](#особенности-работы-с-наследованием)
- [Ограничения наследования](#ограничения-наследования)
- [Для чего нужны триггеры при наследовании в PostgreSQL](#для-чего-нужны-триггеры-при-наследовании-в-postgresql)
  - [Проблема с внешними ключами при наследовании](#проблема-с-внешними-ключами-при-наследовании)
  - [Решение проблемы с помощью триггеров](#решение-проблемы-с-помощью-триггеров)

## Основы объектно-реляционного подхода в PostgreSQL

Объектно-реляционная модель расширяет реляционную модель, добавляя поддержку объектно-ориентированных концепций, таких как:

- **Наследование таблиц**: позволяет создавать иерархии таблиц, где дочерние таблицы наследуют структуру и данные родительской таблицы.
- **Пользовательские типы данных**: дают возможность определять составные, перечислимые или диапазонные типы для точного соответствия предметной области.
- **Пользовательские функции и операторы**: позволяют задавать специфическую логику обработки данных.
- **Агрегатные функции**: обеспечивают выполнение сложных вычислений над наборами данных.

Эти возможности делают PostgreSQL подходящей для задач, требующих сложных структур данных, таких как геоинформационные системы, мультимедийные приложения или научные расчёты.

> [Наверх ⬆️](#содержание)

## Наследование таблиц в PostgreSQL

Наследование таблиц — ключевая особенность объектно-реляционной модели PostgreSQL, позволяющая моделировать иерархии сущностей, аналогично классам в объектно-ориентированном программировании (ООП). Дочерние таблицы наследуют все столбцы, значения по умолчанию и ограничения типа `CHECK` из родительской таблицы, но имеют возможность добавлять собственные столбцы и логику.

> [Наверх ⬆️](#содержание)

## Синтаксис реализации наследования

Наследование задаётся с помощью ключевого слова `INHERITS` при создании таблицы:

```sql
-- Создание родительской таблицы
CREATE TABLE person (
    id SERIAL PRIMARY KEY,
    name TEXT NOT NULL,
    birth_date DATE
);

-- Создание дочерней таблицы, наследующей person
CREATE TABLE employee (
    employee_id TEXT NOT NULL,
    department TEXT,
    hire_date DATE
) INHERITS (person);
```

В этом примере таблица `employee` наследует столбцы `id`, `name` и `birth_date` от таблицы `person`, добавляя свои собственные столбцы: `employee_id`, `department` и `hire_date`.

> [Наверх ⬆️](#содержание)

## Что наследуется и что не наследуется

| Наследуется                  | Не наследуется                               |
| ---------------------------- | -------------------------------------------- |
| Столбцы родительской таблицы | Ограничения уникальности (`UNIQUE`)          |
| Ограничения `CHECK`          | Ограничения первичного ключа (`PRIMARY KEY`) |
| Значения по умолчанию        | Ограничения внешнего ключа (`FOREIGN KEY`)   |
| Комментарии к столбцам       | Индексы                                      |
| Пользовательские типы данных | Триггеры и правила                           |

**Важно**: Ограничения (`PRIMARY KEY`, `UNIQUE`, `FOREIGN KEY`) и индексы не наследуются автоматически, чтобы избежать конфликтов в дочерних таблицах. Их необходимо явно задавать для каждой таблицы при необходимости. Например, если требуется уникальность `id` в дочерней таблице, нужно добавить:

```sql
ALTER TABLE employee ADD CONSTRAINT employee_pk PRIMARY KEY (id);
```

> [Наверх ⬆️](#содержание)

## Особенности работы с наследованием

1. **Запросы к родительской таблице**: По умолчанию запросы к родительской таблице включают данные из всех дочерних таблиц. Например:

   ```sql
   SELECT * FROM person;
   ```

   Этот запрос вернёт строки как из `person`, так и из `employee`.

2. **Запросы только к родительской таблице**: Для исключения данных из дочерних таблиц используется модификатор `ONLY`:

   ```sql
   SELECT * FROM ONLY person;
   ```

3. **Вложенное наследование**: PostgreSQL поддерживает многоуровневое наследование. Например:

   ```sql
   CREATE TABLE manager (
       manager_level INTEGER
   ) INHERITS (employee);
   ```

   Здесь `manager` наследует как от `employee`, так и (косвенно) от `person`.

4. **Полнофункциональность дочерних таблиц**: Дочерние таблицы полностью функциональны и могут использоваться в операциях `INSERT`, `UPDATE`, `DELETE` и `JOIN` независимо от родительской таблицы.

> [Наверх ⬆️](#содержание)

## Ограничения наследования

- **Отсутствие автоматической маршрутизации**: PostgreSQL не перенаправляет данные в дочерние таблицы автоматически. Например, вставка в `person` не перенаправляется в `employee`, даже если данные соответствуют структуре `employee`.
- **Ограничения целостности**: Первичные и внешние ключи, а также индексы нужно задавать вручную для каждой дочерней таблицы.
- **Производительность**: При большом количестве дочерних таблиц запросы к родительской таблице могут замедляться, так как PostgreSQL сканирует все дочерние таблицы.

> [Наверх ⬆️](#содержание)

## Для чего нужны триггеры при наследовании в PostgreSQL

Наследование в PostgreSQL позволяет создавать иерархии таблиц, где таблицы-потомки наследуют структуру и данные родительской таблицы. Однако при использовании наследования возникают сложности, если в базе данных присутствуют внешние ключи, ссылающиеся на таблицу-предка.

### Проблема с внешними ключами при наследовании

Таблица `project` имеет внешний ключ `manager_id`, ссылающийся на поле `id` таблицы `person`. Поскольку `employee` наследует от `person`, записи в `employee` доступны в выборке из `person` при стандартных запросах. Однако ограничение `FOREIGN KEY` проверяет только данные, физически хранящиеся в таблице `person`, игнорируя записи в таблицах-потомках, таких как `employee`.

```sql
CREATE TABLE person (
    id SERIAL PRIMARY KEY,
    name TEXT
);

CREATE TABLE employee (
    department TEXT
) INHERITS (person);

CREATE TABLE project (
    id SERIAL PRIMARY KEY,
    name TEXT,
    manager_id INTEGER REFERENCES person(id)
);
```

**Проблема** возникает при попытке вставить запись в таблицу `project`, ссылающуюся на `id`, который находится в таблице `employee`:

```sql
INSERT INTO employee (name, department) VALUES ('Alice', 'IT');
-- id = 1 создаётся в employee

INSERT INTO project (name, manager_id) VALUES ('New Project', 1);
```

Эта операция завершится ошибкой:

```text
ERROR: insert or update on table "project" violates foreign key constraint ...
DETAIL: Key (manager_id)=(1) is not present in table "person".
```

### Решение проблемы с помощью триггеров

Для решения проблемы необходимо не устанавливать ограничение FOREIGN KEY в таблице `project` с внешним ключом, ссылающимся на таблицу-предка `person`:

```sql
CREATE TABLE project (
    id SERIAL PRIMARY KEY,
    name TEXT,
    manager_id -- FK -> person.id 
);
```

Функционал этого ограничения реализуется триггерами.

1. **Триггер для проверки внешнего ключа при вставке или обновлении**

    Для проверки, что `manager_id` в таблице `project` ссылается на действительный `id` из `person` или её потомков, создаётся триггер:

    ```sql
    CREATE OR REPLACE FUNCTION project_manager_check()
    RETURNS TRIGGER AS $$
    BEGIN
        IF NOT EXISTS (
            SELECT 1 FROM person WHERE id = NEW.manager_id
        ) THEN
            RAISE EXCEPTION 'manager_id % not found in person or its descendants', NEW.manager_id;
        END IF;
        RETURN NEW;
    END;
    $$ LANGUAGE plpgsql;

    CREATE TRIGGER project_manager_trigger
    BEFORE INSERT OR UPDATE ON project
    FOR EACH ROW
    EXECUTE FUNCTION project_manager_check();
    ```

    Этот триггер проверяет, существует ли `manager_id` в выборке из `person`, которая по умолчанию включает данные из всех таблиц-потомков (например, `employee`). Если `id` не найден, выбрасывается исключение, предотвращающее вставку или обновление.

2. **Триггер для обработки обновления или удаления в таблице-предке**

    Обновление или удаление записей в таблице `person` может нарушить целостность внешнего ключа в таблице `project`, если `id` изменяется или удаляется. Для предотвращения таких нарушений создаётся триггер, который проверяет наличие зависимых записей в `project` перед обновлением или удалением:

    ```sql
    CREATE OR REPLACE FUNCTION person_restrict_changes()
    RETURNS TRIGGER AS $$
    BEGIN
        IF EXISTS (
            SELECT 1 FROM project WHERE manager_id = OLD.id
        ) THEN
            RAISE EXCEPTION 'Cannot update or delete person with id % due to dependent records in other table', OLD.id;
        END IF;
        RETURN OLD;
    END;
    $$ LANGUAGE plpgsql;

    CREATE TRIGGER person_restrict_trigger
    BEFORE UPDATE OR DELETE ON person
    FOR EACH ROW
    EXECUTE FUNCTION person_restrict_changes();
    ```

    Этот триггер предотвращает обновление поля `id` или удаление записи в таблице `person`, если на неё ссылаются записи в таблице `project`. Он проверяет выборку из `person`, включая данные из таблиц-потомков, таких как `employee`, и выбрасывает исключение при наличии зависимостей.

> [Наверх ⬆️](#содержание)
