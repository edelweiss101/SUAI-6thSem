# 5. Пользовательские агрегатные функции в объектно-реляционных базах данных на примере PostgreSQL

[◀️ К списку вопросов](README.md)

## Содержание

- [Назначение пользовательских агрегатных функций](#назначение-пользовательских-агрегатных-функций)
- [Создание обычной агрегатной функции](#создание-обычной-агрегатной-функции)
- [Создание оконной агрегатной функции](#создание-оконной-агрегатной-функции)
- [Изменение агрегатной функции](#изменение-агрегатной-функции)
- [Удаление агрегатной функции](#удаление-агрегатной-функции)

## Назначение пользовательских агрегатных функций

Пользовательские агрегатные функции используются для:

- Реализации нестандартных алгоритмов агрегации, отсутствующих среди встроенных функций.
- Поддержки вычислений над пользовательскими типами данных, такими как составные или геометрические типы.
- Выполнения поэтапных вычислений с инициализацией, накоплением и финализацией.
- Создания агрегатов, работающих в оконном контексте для аналитических запросов.

> [Наверх ⬆️](#содержание)

## Создание обычной агрегатной функции

Агрегатная функция состоит из функции перехода состояния (`SFUNC`), типа состояния (`STYPE`) и начального значения (`INITCOND`). При необходимости добавляется функция финализации (`FINALFUNC`) для обработки конечного результата.

**Пример: Агрегат для вычисления произведения чисел:**

```sql
-- Функция перехода состояния
CREATE OR REPLACE FUNCTION product_state(state numeric, next numeric)
RETURNS numeric AS $$
BEGIN
    RETURN COALESCE(state, 1) * COALESCE(next, 1);
END;
$$ LANGUAGE plpgsql;

-- Создание агрегатной функции
CREATE AGGREGATE product(numeric) (
    SFUNC = product_state,
    STYPE = numeric,
    INITCOND = 1
);
```

**Параметры:**

- `SFUNC`: Функция перехода, обновляющая состояние на основе нового значения.
- `STYPE`: Тип данных для хранения промежуточного состояния.
- `INITCOND`: Начальное значение состояния (по умолчанию `NULL`, если не указано).
- `FINALFUNC` (опционально): Функция для финальной обработки состояния.

**Использование:**

```sql
SELECT product(value) FROM (VALUES (2), (3), (4)) AS t(value);
```

Результат: `24` (2 × 3 × 4).

> [Наверх ⬆️](#содержание)

## Создание оконной агрегатной функции

Оконные агрегатные функции работают в контексте оконных выражений (`OVER (PARTITION BY ...)`), позволяя вычислять значения для каждой строки в окне. Для их корректной работы с функцией финализации требуется параметр `FINALFUNC_MODIFY`.

**Пример: Пользовательский агрегат для вычисления среднего значения:**

```sql
-- Функция перехода состояния (сумма и счётчик)
CREATE OR REPLACE FUNCTION custom_avg_state(state double precision[], val double precision)
RETURNS double precision[] AS $$
BEGIN
    RETURN ARRAY[COALESCE(state[1], 0) + COALESCE(val, 0), COALESCE(state[2], 0) + 1];
END;
$$ LANGUAGE plpgsql;

-- Функция финализации
CREATE OR REPLACE FUNCTION custom_avg_final(state double precision[])
RETURNS double precision AS $$
BEGIN
    IF state[2] = 0 THEN
        RETURN NULL;
    END IF;
    RETURN state[1] / state[2];
END;
$$ LANGUAGE plpgsql;

-- Создание агрегатной функции
CREATE AGGREGATE custom_avg(double precision) (
    SFUNC = custom_avg_state,
    STYPE = double precision[],
    FINALFUNC = custom_avg_final,
    INITCOND = '{0,0}',
    FINALFUNC_MODIFY = READ_WRITE
);
```

**Использование в оконном контексте:**

```sql
SELECT
    department,
    salary,
    custom_avg(salary) OVER (PARTITION BY department) AS avg_dept_salary
FROM employees;
```

**Параметры для оконных функций:**

- `FINALFUNC_MODIFY`: Указывает, как функция финализации взаимодействует с состоянием:
  - `READ_ONLY`: Не изменяет состояние.
  - `SHAREABLE`: Состояние может быть использовано повторно в окне.
  - `READ_WRITE`: Состояние может изменяться (по умолчанию).

> [Наверх ⬆️](#содержание)

## Изменение агрегатной функции

В PostgreSQL агрегатную функцию можно модифицировать с помощью команды `ALTER AGGREGATE` для изменения метаданных, таких как владелец, схема или имя агрегата, либо с помощью команды `CREATE OR REPLACE AGGREGATE` для полного пересоздания функции с обновлённой логикой или параметрами.

**Использование `ALTER AGGREGATE`:**

Команда `ALTER AGGREGATE` позволяет вносить ограниченные изменения в определение агрегатной функции без её удаления. Поддерживаемые действия включают:

- Изменение владельца агрегата:

  ```sql
  ALTER AGGREGATE product(numeric) OWNER TO new_user;
  ```

- Перемещение агрегата в другую схему:

  ```sql
  ALTER AGGREGATE product(numeric) SET SCHEMA new_schema;
  ```

- Переименование агрегата:

  ```sql
  ALTER AGGREGATE product(numeric) RENAME TO product_new;
  ```

**Ограничения `ALTER AGGREGATE`:**

- Нельзя изменить ключевые параметры, такие как `SFUNC`, `STYPE`, `FINALFUNC` или `INITCOND`.
- Для изменения логики или структуры агрегата требуется использовать `CREATE OR REPLACE AGGREGATE` или удалить и пересоздать агрегат.

**Использование `CREATE OR REPLACE AGGREGATE`:**

Команда `CREATE OR REPLACE AGGREGATE` позволяет полностью пересоздать агрегатную функцию, обновляя её параметры или логику без необходимости удаления зависимостей.

**Пример пересоздания:**

```sql
-- Новая функция перехода с дополнительной логикой
CREATE OR REPLACE FUNCTION product_state_log(state numeric, next numeric)
RETURNS numeric AS $$
BEGIN
    RETURN COALESCE(state, 1) * COALESCE(next, 1); -- Логирование, если требуется
END;
$$ LANGUAGE plpgsql;

-- Пересоздание агрегата
CREATE OR REPLACE AGGREGATE product(numeric) (
    SFUNC = product_state_log,
    STYPE = numeric,
    INITCOND = 1
);
```

**Особенности:**

- `CREATE OR REPLACE AGGREGATE` сохраняет зависимости (например, представления или индексы), что делает его предпочтительным для обновления логики.
- Если требуется изменить тип входных данных или кардинально переработать агрегат, может понадобиться удаление с помощью `DROP AGGREGATE` и последующее создание нового агрегата.
- Перед применением `CREATE OR REPLACE AGGREGATE` убедитесь, что новая функция перехода (`SFUNC`) и финализации (`FINALFUNC`) совместимы с существующим типом состояния (`STYPE`).

> [Наверх ⬆️](#содержание)

## Удаление агрегатной функции

Удаление выполняется командой `DROP AGGREGATE` с указанием имени и типа входных данных:

```sql
DROP AGGREGATE custom_avg(double precision) CASCADE;
```

Опция `CASCADE` удаляет зависимости, такие как представления или индексы, использующие агрегат. При перегрузке (если агрегат определён для разных типов) указывайте точную сигнатуру.

> [Наверх ⬆️](#содержание)
