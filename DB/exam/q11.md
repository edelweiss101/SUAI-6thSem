# 11. Графовые структуры, назначение графовых БД, операции CRUD в Neo4j

## Содержание

- [Случаи использования графовых БД](#случаи-использования-графовых-бд)
- [Примеры графовых СУБД](#примеры-графовых-субд)
- [Классификация графовых СУБД](#классификация-графовых-субд)
- [Особенности структуры хранения данных](#особенности-структуры-хранения-данных)
- [Операции CRUD в Neo4j (Cypher)](#операции-crud-в-neo4j-cypher)
  - [Создание данных (CREATE)](#создание-данных-create)
  - [Чтение данных (MATCH, WHERE, RETURN)](#чтение-данных-match-where-return)
  - [Обновление данных (SET, REMOVE)](#обновление-данных-set-remove)
  - [Удаление данных (DELETE, DETACH DELETE)](#удаление-данных-delete-detach-delete)

Графовые базы данных предназначены для хранения и обработки данных, организованных в виде графа, где сущности представлены узлами (nodes), а связи между ними — рёбрами (relationships). Такая структура идеально подходит для моделирования сложных взаимосвязей, где важны не только сами данные, но и их отношения. Neo4j, одна из самых популярных графовых СУБД, использует декларативный язык запросов Cypher для выполнения операций. Графовые базы данных обеспечивают высокую производительность при работе с глубоко связанными данными и широко применяются в задачах, требующих анализа сетей и зависимостей.

## Случаи использования графовых БД

Графовые базы данных применяются в сценариях, где ключевое значение имеют связи между сущностями:

- **Социальные сети**: Анализ связей между пользователями, такими как дружба, подписки, лайки или общие интересы.
- **Рекомендательные системы**: Построение рекомендаций товаров, фильмов или контента на основе предпочтений пользователей и их взаимодействий.
- **Управление ИТ-инфраструктурой**: Моделирование зависимостей между серверами, приложениями и сетевыми компонентами для мониторинга и диагностики.
- **Обнаружение мошенничества**: Выявление подозрительных цепочек транзакций или аномалий в финансовых сетях.
- **Системы управления знаниями**: Построение семантических сетей и онтологий для связывания концепций и данных.
- **Генеалогические исследования**: Моделирование семейных деревьев с учетом родственных связей.
- **Логистика и маршрутизация**: Оптимизация маршрутов в транспортных или коммуникационных сетях.

> [Наверх ⬆️](#содержание)

## Примеры графовых СУБД

- **Neo4j**: Ведущая графовая СУБД с нативной графовой моделью хранения, использующая язык Cypher.
- **ArangoDB**: Мультимодельная СУБД, поддерживающая графы, документы и ключ-значение.
- **OrientDB**: Гибридная СУБД с поддержкой графов и документов.
- **JanusGraph**: Распределённая графовая СУБД, интегрируемая с хранилищами, такими как Apache Cassandra или HBase.
- **Amazon Neptune**: Облачная графовая СУБД, совместимая с Gremlin и SPARQL.
- **TigerGraph**: Оптимизирована для аналитических запросов на больших графах.

> [Наверх ⬆️](#содержание)

## Классификация графовых СУБД

1. **По назначению**:
   - **OLTP-графы (Online Transaction Processing, Обработка транзакций в реальном времени)**: Ориентированы на транзакционные операции, такие как добавление узлов, связей, обновление свойств или удаление данных. Эти системы оптимизированы для высокой скорости обработки множества небольших транзакций в реальном времени, обеспечивая низкую латентность и высокую согласованность. Примеры: Neo4j, ArangoDB.
   - **OLAP-графы (Online Analytical Processing)**: Предназначены для аналитических запросов на больших графах, таких как анализ сетей, рекомендации, выявление сообществ или обнаружение аномалий. Эти системы оптимизированы для обработки сложных вычислений и больших объёмов данных, часто жертвуя скоростью транзакций ради аналитической производительности. Примеры: TigerGraph, Dgraph.

2. **По особенностям реализации**:
   - **Нативные графовые СУБД**: Используют графовую модель на уровне хранения данных, обеспечивая высокую производительность для обхода графа. Пример: Neo4j.
   - **Ненативные графовые СУБД**: Реализуют графовую модель поверх других хранилищ (реляционных или документных). Пример: AllegroGraph.

> [Наверх ⬆️](#содержание)

## Особенности структуры хранения данных

Графовые базы данных используют следующие основные элементы:

- **Узлы (Nodes)**: Представляют сущности (например, люди, товары, города). Узлы могут иметь метки (labels) для классификации (например, `:Person`, `:City`) и свойства (key-value пары, такие как `name: "Alice"`).
- **Связи (Relationships)**: Ориентированные рёбра, соединяющие узлы, с указанием типа (например, `:LIVES_IN`, `:FRIEND_OF`) и возможными свойствами (например, `since: 2020`).
- **Свойства (Properties)**: Атрибуты узлов и связей, хранящиеся как пары ключ-значение (например, `age: 30`, `weight: 2.5`).
- **Граф данных**: Единая связная структура, состоящая из узлов и рёбер, которая хранится и оптимизируется для быстрого обхода связей.

**Пример структуры в Neo4j**:

- Узел: `(p:Person {name: "Alice", age: 30})`
- Связь: `(p)-[:LIVES_IN {since: 2020}]->(c:City {name: "Berlin"})`

Эта структура позволяет эффективно моделировать сложные сети, такие как социальные графы или цепочки поставок.

> [Наверх ⬆️](#содержание)

## Операции CRUD в Neo4j (Cypher)

Neo4j использует язык Cypher для выполнения операций создания, чтения, обновления и удаления данных (CRUD). Cypher — декларативный язык, который позволяет описывать шаблоны графа (узлы и связи) и манипулировать ими. Каждая операция имеет чёткий синтаксис, поддерживающий настройку поведения через дополнительные параметры, такие как условия, индексация и транзакции. Все операции выполняются в рамках транзакций, обеспечивая атомарность и согласованность данных.

### Создание данных (CREATE)

Операция `CREATE` используется для создания новых узлов, связей или их комбинаций в графе. Узлы могут иметь метки (labels) для классификации и свойства (key-value пары), а связи — тип и свойства.

**Синтаксис создания узла**:

```cypher
CREATE (variable:Label1:Label2 { property1: value1, property2: value2, ... })
RETURN variable
```

- `variable`: Переменная для ссылки на узел в запросе (например, `p` для узла `Person`).
- `Label1:Label2`: Одна или несколько меток, определяющих тип узла (например, `:Person:Employee`).
- `{ property1: value1, ... }`: Объект с парами ключ-значение для свойств узла (например, `name: "Alice"`).
- `RETURN`: Опционально возвращает созданный узел или его свойства.

**Синтаксис создания связи**:

```cypher
CREATE (node1)-[variable:RELATION_TYPE { property1: value1, ... }]->(node2)
RETURN node1, variable, node2
```

- `node1`, `node2`: Переменные или шаблоны существующих/новых узлов.
- `variable:RELATION_TYPE`: Переменная и тип связи (например, `r:LIVES_IN`).
- `{ property1: value1, ... }`: Свойства связи (опционально).

**Пример создания узла и связи**:

```cypher
CREATE (p:Person {name: "Alice", age: 30, email: "alice@example.com"})
CREATE (c:City {name: "Berlin", country: "Germany", population: 3669491})
CREATE (p)-[r:LIVES_IN {since: 2020, status: "resident"}]->(c)
RETURN p, r, c
```

**Результат**:

```json
[
  {
    "p": { "name": "Alice", "age": 30, "email": "alice@example.com" },
    "r": { "since": 2020, "status": "resident" },
    "c": { "name": "Berlin", "country": "Germany", "population": 3669491 }
  }
]
```

**Особенности**:

- `CREATE` добавляет новые элементы в граф, даже если они уже существуют (для уникальности используйте `MERGE`).
- Свойства могут быть любого типа, поддерживаемого Neo4j (строки, числа, булевы значения, списки, `null`).
- Для предотвращения дублирования можно использовать ограничения уникальности:

```cypher
CREATE CONSTRAINT FOR (p:Person) REQUIRE p.name IS UNIQUE
```

**Пример с `MERGE` для предотвращения дублирования**:

```cypher
MERGE (p:Person {name: "Alice"})
SET p.age = 30, p.email = "alice@example.com"
RETURN p
```

`MERGE` создаёт узел, если он не существует, или возвращает существующий, избегая дублирования.

### Чтение данных (MATCH, WHERE, RETURN)

Операция `MATCH` используется для поиска узлов и связей по шаблону графа. В сочетании с `WHERE` и `RETURN` она позволяет фильтровать и форматировать результаты.

**Синтаксис**:

```cypher
MATCH (variable1:Label1 {property: value})-[variable2:RELATION_TYPE]->(variable3:Label3)
WHERE <condition>
RETURN <expressions>
[ORDER BY <expression> [ASC|DESC]]
[SKIP <number>]
[LIMIT <number>]
```

- `MATCH`: Определяет шаблон графа (узлы и связи). Переменные (`variable1`, `variable2`, ...) используются для ссылки на элементы.
- `WHERE`: Уточняет условия фильтрации (например, `variable1.age > 18`).
- `RETURN`: Указывает, какие данные вернуть (узлы, свойства, связи или вычисляемые значения).
- `ORDER BY`: Сортирует результаты по указанным полям.
- `SKIP`: Пропускает заданное количество записей.
- `LIMIT`: Ограничивает количество возвращаемых записей.

**Пример поиска узлов и связей**:

```cypher
MATCH (p:Person)-[r:LIVES_IN]->(c:City)
WHERE c.name = "Berlin" AND p.age >= 18
RETURN p.name, p.age, c.name, r.since
ORDER BY p.age DESC
LIMIT 2
```

**Результат**:

```json
[
  { "p.name": "Alice", "p.age": 30, "c.name": "Berlin", "r.since": 2020 },
  { "p.name": "Bob", "p.age": 25, "c.name": "Berlin", "r.since": 2021 }
]
```

Этот запрос находит людей, живущих в Берлине, старше 18 лет, возвращает их имена, возраст, город и год начала проживания, сортирует по убыванию возраста и ограничивает результат двумя записями.

**Пример поиска пути переменной длины**:

```cypher
MATCH path = (p:Person {name: "Alice"})-[:FRIEND_OF*1..3]->(f:Person)
WHERE f.age > 25
RETURN p.name, f.name, length(path) AS distance
```

**Результат**:

```json
[
  { "p.name": "Alice", "f.name": "Charlie", "distance": 2 },
  { "p.name": "Alice", "f.name": "David", "distance": 3 }
]
```

Этот запрос находит друзей Алисы (до третьей степени связности), старше 25 лет, и возвращает их имена и длину пути.

**Особенности**:

- Поддерживаются операторы: сравнения (`=`, `<>`, `>`, `<`, `>=`, `<=`), логические (`AND`, `OR`, `NOT`), работа со списками (`IN`, `CONTAINS`), регулярные выражения (`=~`).
- Для сложных шаблонов можно использовать `*` для путей переменной длины (например, `[:FRIEND_OF*1..3]`).
- Индексы ускоряют выполнение запросов:

```cypher
CREATE INDEX FOR (p:Person) ON (p.name)
```

### Обновление данных (SET, REMOVE)

Операция обновления изменяет свойства, метки узлов или связей. Используются команды `SET` для добавления/обновления и `REMOVE` для удаления свойств или меток.

**Синтаксис SET**:

```cypher
MATCH (variable:Label {property: value})
SET variable.property = value
    | variable.property1 = value1, variable.property2 = value2
    | variable:Label2
    | variable.property = expression
```

- `SET variable.property = value`: Обновляет или создаёт свойство.
- `SET variable:Label2`: Добавляет метку к узлу.
- `SET variable.property = expression`: Устанавливает значение на основе выражения (например, `variable.age + 1`).

**Синтаксис REMOVE**:

```cypher
MATCH (variable:Label {property: value})
REMOVE variable.property
       | variable:Label
```

- `REMOVE variable.property`: Удаляет указанное свойство.
- `REMOVE variable:Label`: Удаляет метку.

**Пример обновления свойств**:

```cypher
MATCH (p:Person {name: "Alice"})
SET p.age = 31, p.email = "alice@newemail.com", p.lastUpdated = date("2025-06-02")
RETURN p
```

**Результат**:

```json
[
  { "name": "Alice", "age": 31, "email": "alice@newemail.com", "lastUpdated": "2025-06-02" }
]
```

Этот запрос обновляет возраст, email и добавляет дату обновления для Алисы.

**Пример добавления и удаления метки**:

```cypher
MATCH (p:Person {name: "Alice"})
SET p:Employee
REMOVE p:Student
RETURN labels(p)
```

**Результат**:

```json
[
  { "labels(p)": ["Person", "Employee"] }
]
```

Этот запрос добавляет метку `Employee` и удаляет метку `Student`.

**Пример обновления свойства связи**:

```cypher
MATCH (p:Person {name: "Alice"})-[r:LIVES_IN]->(c:City)
SET r.since = 2019, r.status = "permanent"
RETURN r
```

**Результат**:

```json
[
  { "since": 2019, "status": "permanent" }
]
```

**Особенности**:

- `SET` можно комбинировать с `MATCH` и `WHERE` для точечного обновления.
- Для вычисляемых значений используются выражения, такие как `p.age = p.age + 1`.
- Обновления атомарны в рамках транзакции.

### Удаление данных (DELETE, DETACH DELETE)

Операция удаления позволяет удалять узлы, связи или их комбинации. Для удаления узлов с активными связями используется `DETACH DELETE`.

**Синтаксис DELETE**:

```cypher
MATCH (variable:Label {property: value})-[r:RELATION_TYPE]->(variable2)
DELETE variable, r
```

- `DELETE variable, r`: Удаляет указанные узлы и/или связи.
- Узел нельзя удалить, если он имеет связи, без использования `DETACH`.

**Синтаксис DETACH DELETE**:

```cypher
MATCH (variable:Label {property: value})
DETACH DELETE variable
```

- `DETACH DELETE`: Удаляет узел и все связанные с ним связи.

**Пример удаления связи**:

```cypher
MATCH (p:Person {name: "Alice"})-[r:LIVES_IN]->(c:City)
DELETE r
RETURN p, c
```

Этот запрос удаляет связь `LIVES_IN` между Алисой и городом.

**Пример удаления узла**:

```cypher
MATCH (p:Person {name: "Bob"})
WHERE NOT EXISTS { (p)-[]->() } AND NOT EXISTS { ()-[]->(p) }
DELETE p
```

Этот запрос удаляет узел Боба, если у него нет связей.

**Пример удаления узла со связями**:

```cypher
MATCH (p:Person {name: "Alice"})
DETACH DELETE p
```

Этот запрос удаляет узел Алисы и все её связи.

**Пример удаления с фильтрацией**:

```cypher
MATCH (p:Person)-[r:LIVES_IN]->(c:City)
WHERE r.since < 2020
DELETE r
```

Этот запрос удаляет связи `LIVES_IN`, созданные до 2020 года.

**Особенности**:

- `DELETE` требует, чтобы узел не имел связей, иначе возникает ошибка.
- `DETACH DELETE` автоматически удаляет все входящие и исходящие связи.
- Для массового удаления можно использовать транзакции:

```cypher
BEGIN TRANSACTION
MATCH (p:Person)
DETACH DELETE p
COMMIT
```

**Дополнительные аспекты CRUD**:

- **Транзакции**: Все операции выполняются в рамках транзакций, которые можно явно задавать с помощью `BEGIN`, `COMMIT`, `ROLLBACK`.

```cypher
BEGIN TRANSACTION
CREATE (p:Person {name: "Charlie"})
MATCH (c:City {name: "London"})
CREATE (p)-[:LIVES_IN]->(c)
COMMIT
```

- **Индексация**: Индексы ускоряют `MATCH` и `WHERE`:

```cypher
CREATE INDEX FOR (c:City) ON (c.name)
```

- **Ограничения**: Для обеспечения уникальности используйте:

```cypher
CREATE CONSTRAINT FOR (c:City) REQUIRE c.name IS UNIQUE
```

- **Производительность**: Neo4j оптимизирован для обхода графа, поэтому операции `MATCH` с глубокими связями (например, `[:FRIEND_OF*1..3]`) выполняются быстро при наличии индексов.
- **Ошибки**: Попытка удалить узел с активными связями без `DETACH` или создать дублирующий узел при наличии ограничения уникальности вызовет ошибку.

> [Наверх ⬆️](#содержание)
